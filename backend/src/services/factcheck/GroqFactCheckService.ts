import Groq from 'groq-sdk';
import { pool } from '../../config/database';
import { AIMessage } from '../ai/types';
import { retryWithBackoff } from '../../utils/retry';
import { getGroqRateLimitManager } from '../ai/GroqRateLimitManager';
import { FACT_CHECK_CONFIG } from '../../config/constants';

// =====================================================
// Types
// =====================================================

export interface ClaimVerification {
  claim: string;
  verdict: 'accurate' | 'inaccurate' | 'partially_accurate' | 'unverifiable';
  explanation: string;
  confidence: number;
}

export interface FactCheckResult {
  overall_accuracy_score: number;
  accuracy_level: 'highly_accurate' | 'mostly_accurate' | 'partially_accurate' | 'inaccurate';
  summary: string;
  claims_checked: ClaimVerification[];
  total_claims: number;
  verified_claims: number;
  unverifiable_claims: number;
  inaccurate_claims: number;
  status: 'completed' | 'error' | 'rate_limited' | 'skipped';
  processing_time_ms: number;
  error_message?: string;
}

// =====================================================
// Service
// =====================================================

export class GroqFactCheckService {
  private client: Groq;
  private model: string;
  private enabled: boolean;
  private rateLimiter: ReturnType<typeof getGroqRateLimitManager>;

  private static readonly SYSTEM_PROMPT =
    `You are an independent fact-checker for an educational AI chatbot. Your job is to verify the FACTUAL ACCURACY of a response that was generated by a DIFFERENT AI system (Gemini).

CRITICAL RULES:
1. You are INDEPENDENT. The response you are checking was NOT generated by you.
2. Evaluate factual claims ONLY using your own knowledge. Do NOT trust the response's claims at face value.
3. Focus on verifiable factual claims (dates, statistics, definitions, processes, scientific facts).
4. Skip opinion-based or subjective statements.
5. Be fair but rigorous. Educational accuracy matters.
6. If the response cites sources, verify that the claims match what those sources would typically contain.

For each factual claim you identify:
- State the claim clearly
- Give a verdict: accurate, inaccurate, partially_accurate, or unverifiable
- Explain your reasoning briefly

Respond with ONLY valid JSON in this format:
{
  "overall_accuracy_score": <0-100>,
  "accuracy_level": "<highly_accurate|mostly_accurate|partially_accurate|inaccurate>",
  "summary": "<2-3 sentence summary of findings>",
  "claims_checked": [
    {
      "claim": "<the specific factual claim>",
      "verdict": "<accurate|inaccurate|partially_accurate|unverifiable>",
      "explanation": "<brief reasoning>",
      "confidence": <0.0-1.0>
    }
  ]
}

Scoring guide:
- 90-100 (highly_accurate): All or nearly all claims verified accurate
- 70-89 (mostly_accurate): Most claims accurate, minor issues
- 50-69 (partially_accurate): Mix of accurate and inaccurate claims
- 0-49 (inaccurate): Significant factual errors detected`;

  constructor() {
    const apiKey = process.env.GROQ_API_KEY;

    if (!apiKey) {
      console.warn('GROQ_API_KEY not set. Fact-checking disabled.');
      this.enabled = false;
      this.client = null as any;
      this.model = '';
      this.rateLimiter = getGroqRateLimitManager();
      return;
    }

    this.client = new Groq({ apiKey });
    this.model = FACT_CHECK_CONFIG.MODEL;
    this.enabled = FACT_CHECK_CONFIG.ENABLED;
    this.rateLimiter = getGroqRateLimitManager();

    console.log(`Fact-Check Service initialized: model=${this.model}`);
  }

  isEnabled(): boolean {
    return this.enabled && this.client !== null;
  }

  /**
   * Independently fact-check a Gemini response using Groq.
   * Runs asynchronously — stores results in DB.
   *
   * CRITICAL: Gemini has NO control over this prompt.
   * Only raw Gemini output + independent context is passed.
   */
  async factCheck(
    messageId: number,
    geminiResponse: string,
    studentQuestion: string,
    conversationHistory: AIMessage[],
    courseContext: { title?: string; description?: string }
  ): Promise<FactCheckResult> {
    const startTime = Date.now();

    if (!this.isEnabled()) {
      return this.createSkippedResult('disabled', startTime);
    }

    // Check shared rate limit (fact-checker is lower priority than emotional filter)
    if (!this.rateLimiter.canProceed()) {
      console.warn(`Groq rate limit: skipping fact-check (${this.rateLimiter.remaining} remaining)`);
      const result = this.createSkippedResult('rate_limited', startTime);
      await this.storeResult(messageId, result);
      return result;
    }

    try {
      this.rateLimiter.record();

      const userPrompt = this.buildFactCheckPrompt(
        geminiResponse,
        studentQuestion,
        conversationHistory,
        courseContext
      );

      const groqResult = await retryWithBackoff(
        async () => {
          return await this.client.chat.completions.create({
            messages: [
              { role: 'system', content: GroqFactCheckService.SYSTEM_PROMPT },
              { role: 'user', content: userPrompt }
            ],
            model: this.model,
            temperature: FACT_CHECK_CONFIG.TEMPERATURE,
            max_tokens: FACT_CHECK_CONFIG.MAX_TOKENS,
            response_format: { type: 'json_object' }
          });
        },
        { maxRetries: 1, initialDelayMs: 500, maxDelayMs: 1500 }
      );

      const responseText = groqResult.choices[0]?.message?.content || '{}';
      const parsed = JSON.parse(responseText);

      const claimsChecked: ClaimVerification[] = Array.isArray(parsed.claims_checked)
        ? parsed.claims_checked
        : [];

      const result: FactCheckResult = {
        overall_accuracy_score: Math.min(100, Math.max(0, parsed.overall_accuracy_score ?? 50)),
        accuracy_level: parsed.accuracy_level || 'partially_accurate',
        summary: parsed.summary || 'Fact-check completed.',
        claims_checked: claimsChecked,
        total_claims: claimsChecked.length,
        verified_claims: claimsChecked.filter(c => c.verdict === 'accurate').length,
        unverifiable_claims: claimsChecked.filter(c => c.verdict === 'unverifiable').length,
        inaccurate_claims: claimsChecked.filter(c => c.verdict === 'inaccurate').length,
        status: 'completed',
        processing_time_ms: Date.now() - startTime
      };

      await this.storeResult(messageId, result);

      console.log(`Fact-check complete: ${result.overall_accuracy_score}/100, ${result.total_claims} claims (${result.processing_time_ms}ms)`);
      return result;

    } catch (error: any) {
      console.error('Fact-check error:', error.message);
      const result: FactCheckResult = {
        overall_accuracy_score: 0,
        accuracy_level: 'partially_accurate',
        summary: 'Fact-check could not be completed.',
        claims_checked: [],
        total_claims: 0,
        verified_claims: 0,
        unverifiable_claims: 0,
        inaccurate_claims: 0,
        status: 'error',
        processing_time_ms: Date.now() - startTime,
        error_message: error.message
      };
      await this.storeResult(messageId, result);
      return result;
    }
  }

  /**
   * Build the fact-check prompt with full context.
   * CRITICAL: Gemini has NO influence on this prompt —
   * only raw Gemini output is passed as text to verify.
   */
  private buildFactCheckPrompt(
    geminiResponse: string,
    studentQuestion: string,
    conversationHistory: AIMessage[],
    courseContext: { title?: string; description?: string }
  ): string {
    // Include recent conversation for context (last N entries from config)
    const recentHistory = conversationHistory
      .slice(-(FACT_CHECK_CONFIG.MAX_HISTORY_ENTRIES))
      .map(m => `${m.role === 'user' ? 'Student' : 'AI'}: ${m.content.substring(0, 200)}${m.content.length > 200 ? '...' : ''}`)
      .join('\n');

    return `COURSE CONTEXT:
Title: ${courseContext.title || 'Unknown'}
Description: ${courseContext.description || 'Not provided'}

CONVERSATION HISTORY:
${recentHistory || 'First message in conversation.'}

STUDENT'S QUESTION:
${studentQuestion}

AI RESPONSE TO FACT-CHECK (generated by Gemini, a different AI system):
${geminiResponse}

Please analyze the factual accuracy of the AI response above. Check each verifiable claim independently.`;
  }

  private async storeResult(messageId: number, result: FactCheckResult): Promise<void> {
    try {
      await pool.query(
        `INSERT INTO fact_check_results (
          message_id, overall_accuracy_score, accuracy_level, summary,
          claims_checked, total_claims, verified_claims, unverifiable_claims,
          inaccurate_claims, status, error_message, processing_time_ms,
          groq_model, completed_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
        ON CONFLICT (message_id)
        DO UPDATE SET
          overall_accuracy_score = EXCLUDED.overall_accuracy_score,
          accuracy_level = EXCLUDED.accuracy_level,
          summary = EXCLUDED.summary,
          claims_checked = EXCLUDED.claims_checked,
          total_claims = EXCLUDED.total_claims,
          verified_claims = EXCLUDED.verified_claims,
          unverifiable_claims = EXCLUDED.unverifiable_claims,
          inaccurate_claims = EXCLUDED.inaccurate_claims,
          status = EXCLUDED.status,
          error_message = EXCLUDED.error_message,
          processing_time_ms = EXCLUDED.processing_time_ms,
          completed_at = EXCLUDED.completed_at`,
        [
          messageId,
          result.overall_accuracy_score,
          result.accuracy_level,
          result.summary,
          JSON.stringify(result.claims_checked),
          result.total_claims,
          result.verified_claims,
          result.unverifiable_claims,
          result.inaccurate_claims,
          result.status,
          result.error_message || null,
          result.processing_time_ms,
          this.model,
          result.status === 'completed' ? new Date() : null
        ]
      );
    } catch (error: any) {
      console.error('Failed to store fact-check result:', error.message);
    }
  }

  private createSkippedResult(reason: string, startTime: number): FactCheckResult {
    return {
      overall_accuracy_score: 0,
      accuracy_level: 'partially_accurate',
      summary: `Fact-check skipped: ${reason}`,
      claims_checked: [],
      total_claims: 0,
      verified_claims: 0,
      unverifiable_claims: 0,
      inaccurate_claims: 0,
      status: reason === 'rate_limited' ? 'rate_limited' : 'skipped',
      processing_time_ms: Date.now() - startTime
    };
  }
}

// Singleton
let factCheckInstance: GroqFactCheckService | null = null;

export function getGroqFactCheckService(): GroqFactCheckService {
  if (!factCheckInstance) {
    factCheckInstance = new GroqFactCheckService();
  }
  return factCheckInstance;
}
